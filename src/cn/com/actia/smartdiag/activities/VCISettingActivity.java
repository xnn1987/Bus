package cn.com.actia.smartdiag.activities;import java.util.ArrayList;import java.util.List;import java.util.Set;import android.app.AlertDialog;import android.app.AlertDialog.Builder;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.content.Context;import android.content.DialogInterface;import android.content.DialogInterface.OnCancelListener;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Bundle;import android.os.Handler;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;import cn.com.actia.smartdiag.R;import cn.com.actia.smartdiag.constants.Constants;import cn.com.actia.smartdiag.tools.ClsUtils;import cn.com.actia.smartdiag.tools.GetVCIDeviceListener;import cn.com.actia.smartdiag.tools.Utils;import cn.com.actia.smartdiag.wrapper.CloudWebWrapper;import cn.com.actia.smartdiag.wrapper.DiagBusinessLogicWrapper;public class VCISettingActivity extends APPBaseActivity implements		GetVCIDeviceListener, OnClickListener {	TextView mBtn_conneted;	Button mBtn_toConnect;	ImageView mVCIStatus_img;	boolean isfrontofwindow = false;	@Override	protected void onCreate(Bundle savedInstanceState) {		super.onCreate(savedInstanceState);		isfrontofwindow = true;		setContentView(R.layout.vci_setting_layout);		initWidget();		initListener();		checkConnectedBtn();	}	private void checkConnectedBtn() {		mBtn_conneted.setText(Constants.BLUETOOTH_NAME);		if (null != Constants.BLUETOOTH_ADRESS				&& !"".equals(Constants.BLUETOOTH_ADRESS)) {			mVCIStatus_img.setImageResource(R.drawable.vci_setting_vci_4);			mBtn_conneted.setEnabled(true);		} else {			mVCIStatus_img.setImageResource(R.drawable.vci_setting_vci_1);		}		if (isSearching) {			mBtn_toConnect.setText(R.string.vci_setting_click_to_unconnected);		} else {			mBtn_toConnect.setText(R.string.vci_setting_click_to_connected);		}	}	private void initWidget() {		mBtn_conneted = (TextView) findViewById(R.id.vci_setting_vci_connected);		mBtn_toConnect = (Button) findViewById(R.id.vci_setting_click_to_connected);		mVCIStatus_img = (ImageView) findViewById(R.id.vci_setting_vci_vci);	}	private void initListener() {		// mBtn_conneted.setOnClickListener(this);		mBtn_toConnect.setOnClickListener(this);	}	boolean isSearching = false;	int imageSwitched = 1;	private void vciChangeFlash() {		new Thread() {			@Override			public void run() {				final Bitmap bitmap1 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_2);				final Bitmap bitmap2 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_3);				final Bitmap bitmap3 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_5);				final Bitmap bitmap4 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_6);				final Bitmap bitmap5 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_7);				final Bitmap bitmap6 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_8);				final Bitmap bitmap7 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_9);				final Bitmap bitmap8 = BitmapFactory.decodeResource(						getResources(), R.drawable.vci_setting_vci_10);				Runnable r1 = new Runnable() {					public void run() {						System.out.println("changing");						switch (imageSwitched) {						case 1:							mVCIStatus_img.setImageBitmap(bitmap1);							imageSwitched = 2;							break;						case 2:							mVCIStatus_img.setImageBitmap(bitmap2);							imageSwitched = 3;							break;						case 3:							mVCIStatus_img.setImageBitmap(bitmap3);							imageSwitched = 4;							break;						case 4:							mVCIStatus_img.setImageBitmap(bitmap4);							imageSwitched = 5;							break;						case 5:							mVCIStatus_img.setImageBitmap(bitmap5);							imageSwitched = 6;							break;						case 6:							mVCIStatus_img.setImageBitmap(bitmap6);							imageSwitched = 7;							break;						case 7:							mVCIStatus_img.setImageBitmap(bitmap7);							imageSwitched = 8;							break;						case 8:							mVCIStatus_img.setImageBitmap(bitmap8);							imageSwitched = 1;							break;						}					}				};				while (isSearching) {					new Handler(getMainLooper()).post(r1);					try {						sleep(200);					} catch (InterruptedException e) {						e.printStackTrace();					}				}			}		}.start();	}	/**	 * 检查本地设备，如果已经存在此配对设备的信息则返回为true; //此为阻塞线程，不能单独调用	 **/	// TODO	private boolean isPaired(String name, String bluetoothadress) {		int k = 0;		do {			try {				Thread.sleep(1000);			} catch (InterruptedException e) {				e.printStackTrace();			}			Set<BluetoothDevice> pairedDevices = BluetoothAdapter					.getDefaultAdapter().getBondedDevices();			if (pairedDevices.size() > 0) {				/* 循环，判断是否有存在的devices */				for (BluetoothDevice device : pairedDevices) {					if (device.getAddress().equals(bluetoothadress)							&& device.getName().equals(name)) {						return true;					}				}			}		} while (k++ < 20);		return false;	}	public void onStateChange(String msg) {	}	public void onCompleted(final List<BluetoothDevice> tempVCIDevices) {		if (isfrontofwindow) {// 窗口显示在最前面是必要条件，如果窗口没有显示在最前面，那什么也不用做			// ×××××××××××××××××××去除重复的vci××××××××××××××××××××××××//			final List<BluetoothDevice> VCIDevices = new ArrayList<BluetoothDevice>();			for (BluetoothDevice device : tempVCIDevices) {				boolean isThisDeviceHas = false;				for (BluetoothDevice resultDevice : VCIDevices) {					if (resultDevice.getAddress().equals(device.getAddress())// 如果地址，和名称都相同							&& resultDevice.getName().equals(device.getName())) {						isThisDeviceHas = true;					}				}				if (!isThisDeviceHas) {					VCIDevices.add(device);				}			}			// ×××××××× end ××××××××去除重复的vci××××××××× end ××××××××××××//			if (VCIDevices.size() == 0 && isfrontofwindow) {				showMessageDialog(VCISettingActivity.this, R.string.app_prompt,						R.string.bluetooth_no_suitable, Constants.STYLE_NORMAL);			} else if (VCIDevices.size() == 1) {				BluetoothDevice btDevice = VCIDevices.get(0);				boolean hasBondedWithThisVCI = false;				if (/* isPaired(btDevice.getName(), btDevice.getAddress()) */btDevice						.getBondState() == BluetoothDevice.BOND_BONDED) {					String part1 = Utils.getStringResourse(							VCISettingActivity.this,							R.string.vci_setting_completed_part1);					String part2 = btDevice.getName();					String part3 = Utils.getStringResourse(							VCISettingActivity.this,							R.string.vci_setting_completed_part3);					showToast(part1 + " " + part2 + " " + part3);					hasBondedWithThisVCI = true;				}				if (!hasBondedWithThisVCI) {					showTag("未绑定的ci");					try {						System.out.println("btDevice：~~" + 1);						ClsUtils.setPin(btDevice.getClass(), btDevice, "1234"); // 手机和蓝牙采集器配对						ClsUtils.createBond(btDevice.getClass(), btDevice);						ClsUtils.cancelPairingUserInput(btDevice.getClass(),								btDevice);					} catch (Exception e) {						e.printStackTrace();					}				}				if (isSearching) {// 如果没有停止扫描，我需要更新现在使用的设备信息					if (!VCIDevices.get(0).getAddress()							.equals(Constants.BLUETOOTH_ADRESS)							&& Constants.isSelectVehicleConfigSystemInfo) {						new Thread() {							public void run() {								DiagBusinessLogicWrapper.resetWrapper();							};						}.start();						Constants.isSelectVehicleConfigSystemInfo = false;					}					Constants.BLUETOOTH_ADRESS = /* "AA:BB:CC:DD:EE:FF"; */					VCIDevices.get(0).getAddress();					Constants.BLUETOOTH_NAME = VCIDevices.get(0).getName();					if (hasBondedWithThisVCI) {						Utils.cancelDisCovery(VCISettingActivity.this);						setResult(RESULT_OK);						new Thread() {							public void run() {								DiagBusinessLogicWrapper.resetWrapper();							};						}.start();						Constants.isSelectVehicleConfigSystemInfo = false;						VCISettingActivity.this.finish();					} else {						checkConnectedBtn();					}				}			} else {				String[] names = new String[VCIDevices.size()];				for (int i = 0; i < VCIDevices.size(); i++) {					names[i] = VCIDevices.get(i).getName();				}				DialogInterface.OnClickListener cl = new DialogInterface.OnClickListener() {					public void onClick(DialogInterface dialog, int which) {						boolean hasBondedWithThisVCI = false;						VCIDevices.get(which);						if (VCIDevices.get(which).getBondState() == BluetoothDevice.BOND_BONDED) {							String part1 = Utils.getStringResourse(									VCISettingActivity.this,									R.string.vci_setting_completed_part1);							String part2 = VCIDevices.get(which).getName();							String part3 = Utils.getStringResourse(									VCISettingActivity.this,									R.string.vci_setting_completed_part3);							showToast(part1 + " " + part2 + " " + part3);							hasBondedWithThisVCI = true;						}						if (!hasBondedWithThisVCI) {							try {								System.out.println("btDevice：~~" + 2);								ClsUtils.setPin(VCIDevices.get(which)										.getClass(), VCIDevices.get(which),										"1234"); // 手机和蓝牙采集器配对								ClsUtils.createBond(VCIDevices.get(which)										.getClass(), VCIDevices.get(which));								ClsUtils.cancelPairingUserInput(										VCIDevices.get(which).getClass(),										VCIDevices.get(which));							} catch (Exception e) {								e.printStackTrace();							}						}						Constants.BLUETOOTH_ADRESS = /* "AA:BB:CC:DD:EE:FF"; */						VCIDevices.get(which).getAddress();						Constants.BLUETOOTH_NAME = VCIDevices.get(which)								.getName();						if (hasBondedWithThisVCI) {							Utils.cancelDisCovery(VCISettingActivity.this);							setResult(RESULT_OK);							new Thread() {								public void run() {									DiagBusinessLogicWrapper.resetWrapper();								};							}.start();							Constants.isSelectVehicleConfigSystemInfo = false;							VCISettingActivity.this.finish();						} else {							checkConnectedBtn();						}					}				};				if (isfrontofwindow && isSearching)// 如果窗口在顶端，并且没有停止扫描,就需要显示					showListDialog(this, R.string.app_prompt, names, cl);			}			mBtn_toConnect.setText(R.string.vci_setting_click_to_connected);			checkConnectedBtn();			isSearching = false;		}	}	public void showListDialog(Context context, int title, String[] msgs,			DialogInterface.OnClickListener cl) {		Builder builder = new Builder(context);		builder.setTitle(title);		builder.setItems(msgs, cl);		/** 去掉VCI选择框的确定按钮 */		// builder.setNeutralButton(getResources().getString(R.string.app_ok),		// new DialogInterface.OnClickListener() {		// public void onClick(DialogInterface dialog, int which) {		// dialog.cancel();		// }		// });		AlertDialog alertDialog = builder.create();		alertDialog.setOnCancelListener(new OnCancelListener() {			public void onCancel(DialogInterface dialog) {// 当退出vci选择对话框的时候将设置界面初始化				new Handler().post(new Runnable() {					public void run() {						initWidget();						initListener();						checkConnectedBtn();					}				});			}		});		alertDialog.show();	}	public void onError(String msg) {		if (isfrontofwindow) {			if (DiagBusinessLogicWrapper.isVCIConnected().getCode() != 0) {// 如果未连接到vci，如果F在已与vci链接，则要将地址重置				// TODO 真实版本需要这句，此现在为真实版本				Constants.BLUETOOTH_ADRESS = "";				Constants.BLUETOOTH_NAME = "";				new Handler().post(new Runnable() {					public void run() {						showToast(R.string.end_no_new_vci);					}				});			}			if (isSearching)				showMessageDialog(this, getStringResourse(R.string.app_prompt),						msg, Constants.STYLE_NORMAL);			isSearching = false;			checkConnectedBtn();		}	}	/** 将扫描的标记标记为正在扫描 */	public void onGetStart() {		isSearching = true;		mBtn_toConnect.setText(R.string.vci_setting_click_to_unconnected);		vciChangeFlash();	}	public void onClick(View v) {		switch (v.getId()) {		// 点已经连接按钮		case R.id.vci_setting_vci_connected:			break;		// 点击配对按钮		case R.id.vci_setting_click_to_connected:			// TODO 模拟版本不需要这句话，真实版本需要这句，现在为真实版本			Constants.BLUETOOTH_ADRESS = "";			Constants.BLUETOOTH_NAME = "";			if (isSearching) {				mBtn_toConnect.setText(R.string.vci_setting_click_to_connected);				Utils.cancelDisCovery(this);				isSearching = false;				checkConnectedBtn();				return;			}			checkConnectedBtn();			Utils.getVCIDevices(this, this);			break;		default:			break;		}	}	@Override	protected void onDestroy() {		isfrontofwindow = false;		super.onDestroy();	}}